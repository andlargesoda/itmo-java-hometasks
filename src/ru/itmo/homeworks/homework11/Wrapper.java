package ru.itmo.homeworks.homework11;

import java.util.Arrays;

// 1. Что такое обертки над примитивами?
// 2. Когда лучше использовать примитивы, а когда соответствующие классы-обертки?
// 3. Что такое автоупаковка?
// 4. Что такое автораспаковка?
// 5. Основные правила автоупаковки и автораспаковки?
// 6. Полезные методы оберток над примитивами?
public class Wrapper {
    public static void main(String[] args) {
        // 1. Что такое обертки над примитивами?

        // Обертка - класс, который хранит внутри себя значение соответствующего примитивного типа данных
        // Названия классов-оберток очень похожи на названия соответствующих примитивов, или полностью с ними совпадают
        // К оберткам относятся следующие классы: Double, Float, Long, Integer, Short, Byte, Character, Boolean, Void
        // Т.о., для каждого примитивного значения и ключевого слова void есть свой класс двойник
        // Классы-обертки являются неизменяемыми: это означает, что после создания объекта его состояние
        // (значение поля value) не может быть изменено; и задекларированы, как final (от этих классов невозможно наследоваться)
        // Класса обертки содержат в себе методы

        // классы-оболочки числовых типов (кроме Void, Boolean, Character) наследуют абстрактный класс Number
        // Number объявляет методы, которые возвращают значение объекта в каждом из различных числовых форматов

        // Integer integer = new Integer(5); 'Integer(int)' is deprecated and marked for removal
        Integer integer01 = 5;
        System.out.println(integer01);

        // 2. Когда лучше использовать примитивы, а когда соответствующие классы-обертки?

        // Примитивные типы данных используются, если:
        // 1) требуется высокая производительность приложения, т.е. примитивы типов хранятся в стеке, что позволяет иметь к ним быстрый доступ
        // ссылочные типы данных создаются в куче и доступ к ним медленнее
        // 2) невысокий объем доступной памяти, т.е. примитивы занимают меньше место в памяти, чем ссылочные, к которым относится класс-обертки
        // 3) значение по умолчанию не должно быть null, т.е. значение ссылочных типов данных по умолчанию null
        // с другой стороны если значение примитива соответствует по умолчанию, то не понятно была ли проиницилизирована переменная
        // 4) не требуется использование методов и полей, примитивы не являются классом и не имеют методов и полей

        // Классы-обертки используются, если:
        // 1) не требуется высокая производительность приложения
        // 2) высокий объем доступной памяти
        // 3) значение по умолчанию может быть null, т.е. переменная не проиницилизирована
        // 4) требуется использование методов и полей

        // 3,4. Что такое автоупаковка, автораспаковка?

        int int01 = 1;
        Integer integer02 = 2;

        // автоупаковка (autoboxing) - переменной класса-обертки можно присваивать значение примитивного типа
        integer02 = int01;
        System.out.println(integer02);

        // автораспаковка (autounboxing) - переменной примитивного типа можно присваивать объект класса-обертки
        int01 = integer02;
        System.out.println(int01);

        // компилятор знает, что, например, Integer и int одно и тоже, поэтому операция присваивания происходит автоматически

        // параметры методов также подлежат упаковке и распаковке
        printNumber01(int01); // примитив
        printNumber02(integer02); // класс-обертка

        // автоупаковка и автораспаковка не работают для массивов
        // int[] arr = {1,2,3,4,5};
        // printArray(arr); /*не компилируется*/

        // 5. Основные правила автоупаковки и автораспаковки?

        // 1) распаковка и упаковка происходят автоматически, объекты не создаются явно с использованием оператора new
        // 2) параметры методов также подлежать упаковке и распаковке
        // 3) автоупаковка и автораспаковка не работают для массивов

        // 6. Полезные методы оберток над примитивами?

        // 6.1. Метод valueOf() предоставляет второй способ создания объектов оболочек

        // Метод перегруженный, для каждого класса существует два варианта:
        // один принимает на вход значение соответствующего типа, а второй - значение типа String
        Integer integer03 = Integer.valueOf(1); // valueOf(int i)
        Integer integer04= Integer.valueOf("123"); // valueOf(String s)

        // Исключение составляет класс Character - только один метод, принимающий на вход значение char
        // Character character01 = Character.valueOf(); // // valueOf(Char c)

        // в целочисленные классы Byte, Short, Integer, Long добавлен еще один метод, в который можно передать строку,
        // содержащую число в любой системе исчисления. Вторым параметром вы указываете саму систему исчисления.
        Short short01 = Short.valueOf("10101100", 2); // valueOf(String s, int radix)
        System.out.println(short01);

        // 6.2. Метод parseИмяКлассаОбертки() позволяет преобразовывать строку в соответствующее примитивное значение
        // метод valueOf() возвращает объект, а parse() - примитивное значение
        Long long01 = Long.valueOf("23");
        Long long02 = Long.parseLong("11");
        System.out.println(long01);
        System.out.println(long02);

        // 6.3. Метод toString() возвращает читабельную для человека форму значения, содержащегося в оболочке
        // Это позволяет выводить значение, передавая объект оболочки типа методу println()
        Double double01 = Double.valueOf("2.1");
        System.out.println(double01);

        // Также все числовые оболочки типов предоставляют статический метод toString(),
        // на вход которого передается примитивное значение. Метод возвращает значение String
        String string01 = Float.toString(2.7f);
        System.out.println(string01);

        // Integer и Long предоставляют третий вариант toString() метода, позволяющий представить число в любой системе исчисления.
        // Он статический, первый аргумент – примитивный тип, второй - основание системы счисления:
        String string02 = Integer.toString(192, 16); // число 192 переводим в 16-ричную систему исчесления
        System.out.println(string02);

        // 6.4. Методы toHexString(), toOctalString(), toBinaryString()
        // Integer и Long позволяют преобразовывать числа из десятичной системы исчисления к шестнадцатеричной,
        // восьмеричной и двоичной системе
        String string03 = Integer.toBinaryString(168);
        System.out.println(string03);
        String string04 = Integer.toHexString(168);
        System.out.println(string04);
        String string05 = Integer.toOctalString(168);
        System.out.println(string05);
    }

    // метод вывода числа в консоль, на вход метод принимает класса-обертку
    public static void printNumber01(Integer integer02) {
        System.out.println(integer02);
    }

    // метод вывода числа в консоль, на вход метод принимает примитив
    public static void printNumber02(int int01) {
        System.out.println(int01);
    }

    // метод вывода массива в консоль, на вход метод массив класса обертки (не компилируется)
    public static void printArray(Integer[] array) {
        System.out.println(Arrays.toString(array));
    }
}
